using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Lesson52 : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        #region 知识点一 在世界空间下计算 实现法线纹理Shader
        //主要思路
        //在顶点着色器中计算切线空间到世界空间的变换矩阵
        //在片元着色器中进行法线采样转换

        //关键点：
        //1.属性相关（和切下空间下计算相同）

        //2.结构体相关
        //  顶点着色器中传入：
        //  可以使用 UnityCG.cginc 中的 appdata_full
        //  其中包含了我们需要的顶点、法线、切线、纹理坐标相关数据
        //
        //  片元着色器中传入：
        //  自定义一个结构体
        //  其中包含 裁剪空间下坐标、uv坐标、世界空间下顶点位置、变换矩阵

        //3.顶点着色器回调函数中
        //  2-1 顶点坐标模型转裁剪
        //  2-2 单张纹理和法线纹理 UV坐标缩放偏移计算
        //  2-3 模型空间下顶点转换到世界空间下（之后在片元着色器中用于计算视角方向）
        //  2-4 将模型空间下的法线、切线转换到世界空间下
        //  2-5 副切线计算
        //      用世界空间下的法线和切线进行叉乘 再乘以切线中的w（确定副切线方向）
        //  2-6 构建模型空间到切线空间的变换矩阵
        //       |    |     |
        //      切线 副切线 法线
        //       |    |     |

        //4.片元着色器回调函数中
        //  3-1 计算光的方向、视角方向
        //  3-2 取出法线贴图中的法线信息（利用纹理采样函数tex2D）
        //  3-3 利用内置的UnpackNormal函数对法线信息进行逆运算以及可能的解压
        //  3-4 用得到的切线空间的法线数据 乘以 BumpScale 来控制凹凸程度
        //  3-5 将计算完毕后的切线空间下的法线转换到世界空间下

        //  3-6 得到单张纹理颜色和漫反射颜色的叠加颜色
        //  3-7 用切线空间下的 光方向、视角方向、法线方向 进行Blinn Phong光照模型计算
        #endregion

        #region 知识点二 关于光照方向的计算方式
        //计算光照方式的两种方式：
        //1.模拟定向光源
        //直接得到_WorldSpaceLightPos0光照位置 作为光照方向
        //表示光线是平行的，而不是从特定点发射
        //一般模拟太阳光效果 采用这种方式

        //2.模拟点光源
        //用光照位置_WorldSpaceLightPos0 减去 顶点坐标
        //表示光线是从特定点发射的，并朝着顶点方向
        //一般定点光源 采用这种方式
        #endregion

        #region 知识点三 修改凹凸系数的计算方式，让法线系数不影响光照
        //我们目前这种直接让 法线 * 凹凸系数的计算方式
        //并不是一个标准算法
        //因为当凹凸系数趋近于0时，会影响光照模型的计算

        //为了让凹凸系数不影响光的效果
        //有一种专门的算法

        //1.只让法线中的xy乘以凹凸系数
        //tangentNormal.xy *= _BumpScale;

        //2.保证法线为单位向量（让法线不会为0，而是趋近于顶点法线）
        //  x² + y² + z² = 1
        //  z² = 1 - (x² + y²)
        //  z = 根号下(1 - (x² + y²))
        //tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));

        //通过这样的计算，当凹凸系数在0~1之间变化时，会保证法线为单位向量
        //这样就不会影响光照表现了

        //注意：这种算法并不是来自真实的物理规律
        //      只是为了“看起来正常”
        #endregion

        #region 知识点四 提高性能的写法
        //我们目前在v2f结构体中
        //世界坐标顶点位置和变换矩阵使用了
        //float3 和 float3x3 的两个变量来存储

        //但是在很多世界空间下计算 法线贴图的Shader中
        //往往会使用3个 float4 类型的变量来存储它们

        //这样做的目的是因为
        //这种写法在很多情况下可以提高性能，因为它更好地与GPU的硬件架构匹配
        //float4 类型的寄存器是非常高效的
        //因为现代GPU通常会以 4 分量的向量为基本单位进行并行计算
        //float3x3 矩阵相对来说需要更多的寄存器和指令来表示和计算
        #endregion

    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
