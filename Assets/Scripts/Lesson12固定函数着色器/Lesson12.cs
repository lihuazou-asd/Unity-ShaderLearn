using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Lesson12 : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        #region 知识回顾 表面着色器
        //表面着色器是Unity对顶点/片元着色器的封装
        //可以用更少的代码实现复杂的逻辑
        //但是性能和可控性较差
        //它的特点是
        //1.直接在SubShader语句块中书写着色器逻辑
        //2.我们不需要关心也不需要使用多个Pass，每个Pass如何渲染，Unity会在内部帮助我们去处理
        //3.可以使用CG或HLSL两种Shader语言去编写Shader逻辑
        //4.代码量较少，可控性较低，性能消耗较高
        //5.适用于处理需要和各种光源打交道的着色器，但是在移动平台上需要注意性能表现
        #endregion

        #region 知识回顾 顶点/片元着色器
        //它的特点是
        //1.需要在Pass渲染通道中编写着色器逻辑
        //2.可以使用CG或HLSL两种Shader语言去编写Shader逻辑
        //3.代码量较多，灵活性较强，性能消耗更可控，可以实现更多渲染细节
        //4.适用于光照处理较少，自定义渲染效果较多时（移动平台首选）
        #endregion

        #region 知识点 固定函数着色器
        //表面着色器 和 顶点/片元着色器 这两种Unity Shader形式都使用了可编程管线
        //而对于一些老设备（DX7.0、OpenGL1.5或OpenGL ES 1.1），它们不支持可编程管线着色器
        //这时就需要使用固定函数着色器来进行渲染
        //这些着色器只能实现一些非常简单的效果
        //它的特点是：
        //1.需要在Pass渲染通道中编写着色器逻辑
        //2.需要使用ShaderLab语法中的渲染设置命令来编写，而非CG和HLSL着色器语言

        //但是由于这些旧设备目前市面上几乎已经没有了
        //所以固定函数着色器我们几乎不会再使用
        //只做了解即可
        //即使我们现在在Unity中使用固定函数着色器来编写Shader，在内部也会被编译为顶点/片元着色器
        //因此真正意义的固定函数着色器已经不存在了
        #endregion

        #region 总结
        //对于Unity Shader的三种编写形式
        //1.表面着色器
        //2.顶点/片元着色器
        //3.固定函数着色器
        //我们应该如何选择呢？
        //1.固定函数着色器基本已弃用，不是我们学习的重点
        //2.对于PC、主机性能较高的设备，为了追求更好的效果，使用表面着色器可能更加的方便
        //3.对于移动设备，为了权衡效果和性能，优先使用顶点/片元着色器
        //4.在有很多自定义的渲染效果时，优先使用顶点/片元着色器，因为更灵活可控

        //而表面着色器的本质是对顶点/片元着色器的封装
        //所以我们在学习过程中，着重学习顶点/片元着色器开发的相关知识
        #endregion
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
